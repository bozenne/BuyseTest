#+BEGIN_HTML
<a href="https://travis-ci.org/bozenne/BuyseTest"><img src="https://travis-ci.org/bozenne/BuyseTest.svg?branch=master"></a>
<a href="http://cran.rstudio.com/web/packages/BuyseTest/index.html"><img src="http://www.r-pkg.org/badges/version/BuyseTest"></a>
<a href="http://cranlogs.r-pkg.org/downloads/total/last-month/BuyseTest"><img src="http://cranlogs.r-pkg.org/badges/BuyseTest"></a>
<a href="https://ci.appveyor.com/project/bozenne/BuyseTest"><img src="https://ci.appveyor.com/api/projects/status/github/bozenne/BuyseTest?svg=true" alt="Build status"></a>
#+END_HTML

* BuyseTest

*BuyseTest* is a package for the R software
(https://www.r-project.org/) implementing generalized pairwise
comparisons (GPC). This enables to compare two groups of observations
in randomized trials(e.g treated vs. control patients) on several
prioritized outcomes. Pairwise comparisons require consideration of
all possible pairs of individuals, one taken from the treatment group
and the other taken from the control group. The outcomes of the two
individuals forming a pair are compared. Thresholds of minimal
clinically significant differences can be defined. It is possible to
analyse simultaneously several outcomes by prioritizing the variables
that capture them. The highest priority is assigned to the variable
considered the most clinically relevant.  A natural way of handling
uninformative or neutral pairs is to consider the outcomes in
descending order of priority: whenever a pair is uninformative or
neutral for an outcome of higher priority, the outcomes of lower
priority are examined In the case of time-to-event endpoint, four
methods to handle censored observations are available in this package
(Gehan, Peto, Efron, and Peron).

* Installation

You can download the latest stable version on =CRAN= using:
#+BEGIN_SRC R :exports both :eval never
install.packages("BuyseTest")
#+END_SRC

or download the development version from =GitHub=:
#+BEGIN_SRC R :exports both :eval never
library(devtools)
install_github("bozenne/BuyseTest")
#+END_SRC

* Citation
To cite this package in a publications please use:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
citation("BuyseTest")
#+END_SRC

#+RESULTS:
#+begin_example

To cite the 'BuyseTest' package in publications use the citation from
2018.

To cite the statistical method used by BuyseTes 'BuyseTest' package,
use the citation from: (2010) when using BuyseTest binary/continous
endpoint or time to event endpoints with method.tte="Gehan", (2016)
when using BuyseTest with time to event endpoint with
method.tte="Peron".

  Brice Ozenne and Julien Peron (2018). BuyseTest: Implementation of
  the Generalized Pairwise Comparisons. R package version 1.4.2.

  Buyse, M. (2010), Generalized pairwise comparisons of prioritized
  outcomes in the two-sample problem. Statistics in medicine, 29:
  3245-3257. doi:10.1002/sim.3923

  Peron, M. et al. (2018), An extension of generalized pairwise
  comparisons for prioritized outcomes in the presence of censoring.
  Statistical methods in medical research, 27: 1230-1239.
  https://doi.org/10.1177/0962280216658320

To see these entries in BibTeX format, use 'print(<citation>,
bibtex=TRUE)', 'toBibtex(.)', or set
'options(citation.bibtex.max=999)'.
#+end_example

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
toBibtex(citation("BuyseTest"))
#+END_SRC

#+RESULTS:
#+begin_example
@Manual{,
  title = {BuyseTest: Implementation of the Generalized Pairwise Comparisons},
  author = {Brice Ozenne and Julien Peron},
  year = {2018},
  note = {R package version 1.4.2},
}

@Article{,
  title = {Generalized pairwise comparisons of prioritized outcomes in the two-sample problem},
  author = {Marc Buyse},
  year = {2010},
  volume = {29},
  number = {30},
  pages = {3245--3257},
  journal = {Statistics in medicine},
  doi = {https://doi.org/10.1002/sim.3923},
}

@Article{,
  title = {An extension of generalized pairwise comparisons for prioritized outcomes in the presence of censoring},
  author = {{P{'e}ron} and {Julien} and {Buyse} and {Marc} and {Ozenne} and {Brice} and {Roche} and {Laurent} and {Roy} and {Pascal}},
  year = {2018},
  volume = {27},
  number = {4},
  pages = {1230--1239},
  journal = {Statistical methods in medical research},
  doi = {https://doi.org/10.1177/0962280216658320},
}
#+end_example

* Functionalities

Load *BuyseTest* in the R session:
#+BEGIN_SRC R  :results silent   :exports both  :session *R* :cache no
library(BuyseTest)
#+END_SRC


** Simulate data
You can simulate data with the =simBuyseTest= function. For instance
the following code simulates data for 5 individuals in the treatment
arm and 5 individuals in the control arm:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
set.seed(10)
simBuyseTest(n.T = 5, n.C = 5)
#+END_SRC

#+RESULTS:
#+begin_example
    Treatment toxicity       score eventtime status
 1:         C        1  0.54361539 1.8252132      0
 2:         C        1 -0.70762484 2.9489056      1
 3:         C        1 -0.36944577 0.7213402      0
 4:         C        1 -1.32197565 0.6322603      1
 5:         C        1  1.28059746 0.2212117      0
 6:         T        1  0.01874617 0.1453481      0
 7:         T        1 -0.18425254 0.4855601      0
 8:         T        0 -1.37133055 0.2547505      0
 9:         T        1 -0.59916772 1.0340368      0
10:         T        0  0.29454513 0.3579324      1
#+end_example

By default a categorical, continuous and time to event outcome are
generated. You can modify their distribution via the arguments
=argsBin=, =argsCont=, =argsTTE=. For instance the following code
simulates two continuous variables with mean 5 in the treatment arm
and 10 in the control arm all with variance 1:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
set.seed(10)
argsCont <- list(mu.T = c(5,5), mu.C = c(10,10), 
                 sigma.T = c(1,1), sigma.C = c(1,1),
                 name = c("tumorSize","score"))
dt <- simBuyseTest(n.T = 5, n.C = 5,
                   argsCont = argsCont)
dt
#+END_SRC

#+RESULTS:
#+begin_example
    Treatment toxicity tumorSize     score eventtime status
 1:         C        1  9.010394 10.667415 0.2729620      0
 2:         C        0  9.965152 11.691755 0.5562477      0
 3:         C        0 10.847160 10.001261 0.8040608      0
 4:         C        0 11.525498  9.257539 1.8477048      1
 5:         C        1  9.932625 10.609684 0.3639572      1
 6:         T        1  5.389794  5.018746 0.6243732      0
 7:         T        1  3.791924  4.815747 0.3527879      1
 8:         T        1  4.636324  3.628669 1.7731161      0
 9:         T        0  3.373327  4.400832 0.1055467      0
10:         T        0  4.743522  5.294545 0.8612402      0
#+end_example

This functionality is based on the =sim= function of the *lava*
package (https://github.com/kkholst/lava)

** Perform generalized pairwise comparisons (GPC)
*** Specifying GPC using the =BuyseTest= function
Let's consider the veteran dataset:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
data(veteran,package="survival")
head(veteran)
#+END_SRC

#+RESULTS:
:   trt celltype time status karno diagtime age prior
: 1   1 squamous   72      1    60        7  69     0
: 2   1 squamous  411      1    70        5  64    10
: 3   1 squamous  228      1    60        3  38     0
: 4   1 squamous  126      1    60        9  63    10
: 5   1 squamous  118      1    70       11  65    10
: 6   1 squamous   10      1    20        5  49     0

The BuyseTest function performs the generalized pairwise
comparisons (GPC). One needs to specify:
- the object where the data are stored
- the name of the endpoints
- the type of each endpoint: time to event (tte), continuous (cont), or binary (bin)
- the threshold associated to each endpoint (optional, by default 1e-12)
- the censoring associated to each endpoint (only required for time to event variables)
- the operator: is higher better or is lower better (optional, by default higher is better)
There are two equivalent ways to define the GPC: 
- via a formula interface
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.f <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status"),
                  data = veteran, trace = 3, method.inference = "none")
#+END_SRC

#+RESULTS:
: Settings (point estimation) 
:    > treatment groups: Control = 1 and Treatment = 2
:    > 1 endpoint: 
:        priority endpoint type          operator            threshold censoring
:        1        time     time to event higher is favorable 20        status   
:    > management of neutral pairs: re-analyzed using endpoints of lower priority (if any) 
:    > management of censored survival pairs: use Kaplan Meier survival curves to compute the score 
: 
: Point estimation (done)

- or using a separate argument for each element:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT <- BuyseTest(endpoint = "time", 
                type = "timeToEvent", 
                treatment = "trt", 
                censoring = "status", 
                threshold = 20,
                data = veteran, 
                method.inference = "none",
                trace = 0)
#+END_SRC

#+RESULTS:

Here we set in addition the argument =trace= to 0 to force the
function to be silent (i.e. no display in the terminal). Also setting
the argument =method.inference= to ="none"= diseable the computation
of p-values and confidence intervals.

We can check that the two approaches are equivalent:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
testthat::expect_equal(BT.f,BT)
#+END_SRC

#+RESULTS:

The =BuyseTest= function can perform stratified GPC with several endpoints:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT2 <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status") + cont(karno, threshold = 0) + celltype,
                 data = veteran, trace = 0, method.inference = "none")
#+END_SRC

#+RESULTS:

Here we have asked for an analysis stratified on celltype, with two prioritized outcomes:
- first priority: time
- second priority: karno
By setting the argument =method.inference= to "none", we disabled the
estimation of the asymptotic distribution of the test statistic. This
makes the execution of =BuyseTest= much faster.

*** Display the results with the =summary= method
The results of the GPC can be displayed using the =summary= method:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
summary(BT)
#+END_SRC 

#+RESULTS:
:         Generalized pairwise comparison with 1 prioritized endpoint
: 
:  > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
:  > null hypothesis : Delta == 0 
:  > treatment groups: 1 (control) vs. 2 (treatment) 
:  > censored pairs  : use Kaplan Meier survival curves to compute the score
:  > results
:  endpoint threshold total favorable unfavorable neutral uninf   delta   Delta
:      time        20   100     37.78       46.54   15.68     0 -0.0877 -0.0877

By default =summary= displays results relative to the statistic "net
chance of a better outcome". To get results for the win ratio set the
argument =statistic= to "winRatio":
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
summary(BT, statistic = "winRatio")
#+END_SRC

#+RESULTS:
:         Generalized pairwise comparison with 1 prioritized endpoint
: 
:  > statistic       : win ratio (delta: endpoint specific, Delta: global) 
:  > null hypothesis : Delta == 1 
:  > treatment groups: 1 (control) vs. 2 (treatment) 
:  > censored pairs  : use Kaplan Meier survival curves to compute the score
:  > results
:  endpoint threshold total favorable unfavorable neutral uninf  delta  Delta
:      time        20   100     37.78       46.54   15.68     0 0.8117 0.8117

Since we have set the argument =n.permutation= to 0 (i.e. no
permutation test) in the stratified analysis, we do not get confidence
intervals or p.values when calling the =summary= method. When doing a
stratified analysis, the summary method displays the global results as
well as the results within each strata:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
summary(BT2)
#+END_SRC

#+RESULTS:
#+begin_example
        Generalized pairwise comparison with 2 prioritized endpoints and 4 strata

 > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
 > null hypothesis : Delta == 0 
 > treatment groups: 1 (control) vs. 2 (treatment) 
 > censored pairs  : use Kaplan Meier survival curves to compute the score
 > results
 endpoint threshold    strata  total favorable unfavorable neutral uninf   delta   Delta
     time        20    global 100.00     36.06       45.77   17.50  0.68 -0.0971 -0.0971
                     squamous  25.38     14.33        8.77    2.28  0.00  0.0557        
                    smallcell  45.69     12.69       20.88   11.44  0.68 -0.0819        
                        adeno  13.71      4.74        6.15    2.81  0.00 -0.0142        
                        large  15.23      4.30        9.97    0.96  0.00 -0.0567        
    karno     1e-12    global  18.17      6.72        8.07    3.38  0.00 -0.0135 -0.1106
                     squamous   2.28      0.76        0.94    0.59  0.00 -0.0018        
                    smallcell  12.12      4.33        5.75    2.03  0.00 -0.0142        
                        adeno   2.81      1.46        0.85    0.51  0.00  0.0061        
                        large   0.96      0.17        0.54    0.25  0.00 -0.0037
#+end_example

*** What about p-value and confidence intervals?

P-values can be estimated via a permutation test:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.perm <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status"),
                     data = veteran, trace = 0, method.inference = "permutation",
                     n.resampling = 10) 
summary(BT.perm)
#+END_SRC

#+RESULTS:
#+begin_example
        Generalized pairwise comparison with 1 prioritized endpoint

 > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
 > null hypothesis : Delta == 0 
 > permutation test: 10 samples, confidence level 0.95 
 > treatment groups: 1 (control) vs. 2 (treatment) 
 > censored pairs  : use Kaplan Meier survival curves to compute the score
 > results
 endpoint threshold total favorable unfavorable neutral uninf   delta   Delta  CI [2.5 ; 97.5] p.value 
     time        20   100     37.78       46.54   15.68     0 -0.0877 -0.0877 [-0.2412;0.1946]     0.4 
NOTE: confidence intervals computed under the null hypothesis
#+end_example

The argument =n.resampling= indicates the permutation that will be
performed. We set it to 10 to save computation time but to obtain
reliable p-value/confidence intervals, =n.resampling= should be at
least 1000. The validity of the confidence intervals obtained via a
permutation test is questionnable and we recommand instead to use a
bootstrap approach for estimating confidence intervals. To do so, set
the argument =method.inference= to ="bootstrap"= when calling
=BuyseTest=:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.boot <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status"),
                     data = veteran, trace = 0, method.inference = "bootstrap",
                     n.resampling = 10) 
summary(BT.boot)
#+END_SRC

#+RESULTS:
#+begin_example
        Generalized pairwise comparison with 1 prioritized endpoint

 > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
 > null hypothesis : Delta == 0 
 > bootstrap resampling: 10 samples, confidence level 0.95 
 > treatment groups: 1 (control) vs. 2 (treatment) 
 > censored pairs  : use Kaplan Meier survival curves to compute the score
 > results
 endpoint threshold total favorable unfavorable neutral uninf   delta   Delta  CI [2.5 ; 97.5] p.value 
     time        20   100     37.78       46.54   15.68     0 -0.0877 -0.0877 [-0.1794;0.0302]     0.5
#+end_example

*** What if smaller is better?
By default =BuyseTest= will always assume that higher values of an
endpoint are favorable. This behavior can be changed by specifying =operator = "<0"=
for an endpoint:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BTinv <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status", operator = "<0"),
                   data = veteran, method.inference = "none", trace = 0)
BTinv
#+END_SRC

#+RESULTS:
:  endpoint threshold  delta  Delta
:      time        20 0.0844 0.0844

Internally =BuyseTest= will multiply by -1 the values of the endpoint
to ensure that lower values are considered as favorable. A direct
consequence is that =BuyseTest= will not accept an endpoint with
different operators:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
try(BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status", operator = "<0") + tte(time, 10, "status", ">0"),
              data = veteran, method.inference = "none", trace = 0))
#+END_SRC

#+RESULTS:
: Error in (function (alternative, name.call, censoring, correction.uninf,  : 
:   Cannot have different operator for the same endpoint used at different priorities

*** Stopping comparison for neutral pairs
In presence of neutral pairs, =BuyseTest= will, by default, continue
the comparison on the endpoints with lower priority. For instance let
consider a dataset with one observation in each treatment arm:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt.sim <- data.table(Id = 1:2,
                     treatment = c("Yes","No"),
                     tumor = c("Yes","Yes"),
                     size = c(15,20))
dt.sim
#+END_SRC

#+RESULTS:
:    Id treatment tumor size
: 1:  1       Yes   Yes   15
: 2:  2        No   Yes   20

If we perform we GPC with tumor as the first endpoint and size as the
second endpoint:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.pair <- BuyseTest(treatment ~ bin(tumor) + cont(size, operator = "<0"), data = dt.sim,
                     trace = 0, method.inference = "none")
summary(BT.pair)
#+END_SRC

#+RESULTS:
:         Generalized pairwise comparison with 2 prioritized endpoints
: 
:  > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
:  > null hypothesis : Delta == 0 
:  > treatment groups: No (control) vs. Yes (treatment) 
:  > results
:  endpoint threshold total favorable unfavorable neutral uninf delta Delta
:     tumor       0.5   100         0           0     100     0     0     0
:      size     1e-12   100       100           0       0     0     1     1

the outcome of the comparison is neutral for the first priority, but
favorable for the second priority. If we set the argument
=neutral.as.uninf= to =FALSE=, =BuyseTest= will stop the comparison
when a pair is classified as neutral:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.pair2 <- BuyseTest(treatment ~ bin(tumor) + cont(size, operator = "<0"), data = dt.sim,
                     trace = 0, method.inference = "none", neutral.as.uninf = FALSE)
summary(BT.pair2)
#+END_SRC

#+RESULTS:
:         Generalized pairwise comparison with 2 prioritized endpoints
: 
:  > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
:  > null hypothesis : Delta == 0 
:  > treatment groups: No (control) vs. Yes (treatment) 
:  > results
:  endpoint threshold total favorable unfavorable neutral uninf delta Delta
:     tumor       0.5   100         0           0     100     0     0     0
:      size     1e-12     0         0           0       0     0     0     0

So in this case no pair is analyzed at second priority.

*** Extracting the contribution of each pair to the statistic
The net chance of better outcome or the win ratio statistics can be
expressed as a sum over all pairs of patients. The argument
keep.pairScore enables to export the score relative to each pair in
the output of BuyseTest:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.keep <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status") + cont(karno),
                     data = veteran, keep.pairScore = TRUE, 
                     trace = 0, method.inference = "none")
#+END_SRC

#+RESULTS:

The method =getPairScore= can then be used to extract the contribution
of each pair. For instance the following code extracts the
contribution for the first endpoint:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
getPairScore(BT.keep, endpoint = 1)
#+END_SRC

#+RESULTS:
#+begin_example
      strata index.1 index.2 favorable unfavorable neutral uninformative weight favorable.corrected unfavorable.corrected neutral.corrected
   1:      1       1      70         1           0       0             0      1                   1                     0                 0
   2:      1       2      70         1           0       0             0      1                   1                     0                 0
   3:      1       3      70         1           0       0             0      1                   1                     0                 0
   4:      1       4      70         1           0       0             0      1                   1                     0                 0
   5:      1       5      70         1           0       0             0      1                   1                     0                 0
  ---                                                                                                                                      
4688:      1      65     137         0           1       0             0      1                   0                     1                 0
4689:      1      66     137         0           1       0             0      1                   0                     1                 0
4690:      1      67     137         0           1       0             0      1                   0                     1                 0
4691:      1      68     137         0           1       0             0      1                   0                     1                 0
4692:      1      69     137         0           1       0             0      1                   0                     1                 0
#+end_example

Each line corresponds to different comparison between a pair from the
control arm and the treatment arm. The column =strata= store to which
strata the pair belongs (first, second, ...). The columns favorable,
unfavorable, neutral, uninformative contains the result of the
comparison, e.g. the first pair was classified as favorable while the
last was classified as favorable with a weight of 1. The second and
third columns indicates the rows in the original dataset corresponding
to the pair:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
veteran[c(70,1),]
#+END_SRC

#+RESULTS:
:    trt celltype time status karno diagtime age prior
: 70   2 squamous  999      1    90       12  54    10
: 1    1 squamous   72      1    60        7  69     0


For the first pair, the event was observed for both observations and
since 999 > 72 + 20 the pair is rated favorable. Substracting the
average probability of the pair being favorable minus the average
probability of the pair being unfavorable:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
getPairScore(BT.keep, endpoint = 1)[, mean(favorable) - mean(unfavorable)]
#+END_SRC

#+RESULTS:
: [1] -0.08765836

 gives the net benefit in favor of the treatment for the first
 endpoint:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT.keep
#+END_SRC

#+RESULTS:
:  endpoint threshold   delta   Delta
:      time        20 -0.0877 -0.0877
:     karno     1e-12 -0.0133 -0.1009

More examples and explaination can be found in the documentation of
the method =getPairScore=.

*** Extracting the survival probabilities
When using method.tte="Peron", survival probabilities at event time,
and event times +/- threshold in the control and treatment arms are
used to score the pair. Setting keep.survival to TRUE in
BuyseTest.options enables to export the survival probabilities in the
output of BuyseTest:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest.options(keep.survival = TRUE)
BT.keep2 <- BuyseTest(trt ~ tte(time, threshold = 20, censoring = "status") + cont(karno),
                      data = veteran, keep.pairScore = TRUE, method.tte = "Peron",
                      trace = 0, method.inference = "none")
#+END_SRC

#+RESULTS:


The method =getSurvival= can then be used to extract these survival
probabilities.For instance the following code extracts the
survival for the first endpoint:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
outSurv <- getSurvival(BT.keep2, endpoint = 1, strata = 1)
str(outSurv)
#+END_SRC

#+RESULTS:
#+begin_example
List of 5
 $ survTimeC: num [1:69, 1:7] 72 411 228 126 118 10 82 110 314 100 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:7] "time" "SurvivalC-threshold" "SurvivalC_0" "SurvivalC+threshold" ...
 $ survTimeT: num [1:68, 1:7] 999 112 87 231 242 991 111 1 587 389 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:7] "time" "SurvivalC-threshold" "SurvivalC_0" "SurvivalC+threshold" ...
 $ survJumpC: num [1:57, 1:3] 3 4 7 8 10 11 12 13 16 18 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:3] "time" "survival" "dSurvival"
 $ survJumpT: num [1:51, 1:3] 1 2 7 8 13 15 18 19 20 21 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:3] "time" "survival" "dSurvival"
 $ lastSurv : Named num [1:2] 0 0
  ..- attr(*, "names")= chr [1:2] "Control" "Treatment"
#+end_example

Let's look at pair 91:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
getPairScore(BT.keep2, endpoint = 1, rm.withinStrata = FALSE)[91]
#+END_SRC

#+RESULTS:
:    strata index.1 index.2 indexWithinStrata.1 indexWithinStrata.2 favorable unfavorable   neutral uninformative weight favorable.corrected
: 1:      1      22      71                  22                   2         0   0.6950827 0.3049173             0      1                   0
:    unfavorable.corrected neutral.corrected
: 1:             0.6950827         0.3049173

In the dataset this corresponds to:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
veteran[c(22,71),]
#+END_SRC

#+RESULTS:
:    trt  celltype time status karno diagtime age prior
: 22   1 smallcell   97      0    60        5  67     0
: 71   2  squamous  112      1    80        6  60     0

The observation from the control group is censored at 97 while the
observation from the treatment group has an event at 112. Since the
threshold is 20, and (112-20)<97, we know that the pair is not in
favor of the treatment. The formula for probability in favor of the
control is Sc(97)/Sc(112+20). The survival at the event time in the
censoring group is stored in survTimeC. Since observation 23 is the
22th observation in the control group:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iSurv <- outSurv$survTimeC[22,] 
iSurv
#+END_SRC 

#+RESULTS:
:                time SurvivalC-threshold         SurvivalC_0 SurvivalC+threshold SurvivalT-threshold         SurvivalT_0 SurvivalT+threshold 
:          97.0000000           0.5615232           0.5171924           0.4235463           0.4558824           0.3643277           0.2827500
Since we are interested in the survival in the control arm exactly at the event time:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
Sc97 <- iSurv["SurvivalC_0"] 
Sc97
#+END_SRC

#+RESULTS:
: SurvivalC_0 
:   0.5171924

The survival at the event time in the treatment group is stored in
survTimeC. Since observation 71 is the 2nd observation in the treatment
group:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iSurv <- outSurv$survTimeT[2,] ## survival at time 112+20
iSurv
#+END_SRC

#+RESULTS:
:                time SurvivalC-threshold         SurvivalC_0 SurvivalC+threshold SurvivalT-threshold         SurvivalT_0 SurvivalT+threshold 
:         112.0000000           0.5319693           0.4549201           0.3594915           0.3801681           0.2827500           0.2827500

Since we are interested in the survival in the control arm at the event time plus threshold:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
Sc132 <- iSurv["SurvivalC+threshold"] 
Sc132
#+END_SRC

#+RESULTS:
: SurvivalC+threshold 
:           0.3594915

The probability in favor of the control is then:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
Sc132/Sc97
#+END_SRC

#+RESULTS:
: SurvivalC+threshold 
:           0.6950827

When both observations are censored, the formula for computing the
probability in favor of treatment or control involves an
integral. This integral can be computed using the function
calcIntegralProba_cpp that takes as argument a matrix containing the
survival and the jumps in survival, e.g.:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
head(outSurv$survJumpT)
#+END_SRC

#+RESULTS:
:      time  survival   dSurvival
: [1,]    1 0.7681159 -0.02941176
: [2,]    2 0.7536232 -0.01470588
: [3,]    7 0.7388463 -0.02941176
: [4,]    8 0.7388463 -0.02941176
: [5,]   13 0.7092924 -0.01470588
: [6,]   15 0.6945155 -0.02941176

and the starting time of the integration time. For instance, let's
look at pair 148:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
getPairScore(BT.keep2, endpoint = 1, rm.withinStrata = FALSE)[148]
#+END_SRC

#+RESULTS:
:    strata index.1 index.2 indexWithinStrata.1 indexWithinStrata.2 favorable unfavorable   neutral uninformative weight favorable.corrected
: 1:      1      10      72                  10                   3 0.5058685   0.3770426 0.1170889             0      1           0.5058685
:    unfavorable.corrected neutral.corrected
: 1:             0.3770426         0.1170889

which corresponds to the observations:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
veteran[c(10,72),]
#+END_SRC

#+RESULTS:
:    trt celltype time status karno diagtime age prior
: 10   1 squamous  100      0    70        6  70     0
: 72   2 squamous   87      0    80        3  48     0

The probability in favor of the treatment and control can be computed
as \(-\int_(t>y) S_T(t+\tau) dS_C(t)/(S_T(x)S_C(y))\) and \(-\int_(t>x) S_C(t+\tau)
dS_T(t)/(S_T(x)S_C(y))\) where \(x=87\) and \(y=100\). We obtain:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
denom <- as.double(outSurv$survTimeT[3,"SurvivalT_0"] * outSurv$survTimeC[10,"SurvivalC_0"])
c("favorable" = -calcIntegralProba_cpp(outSurv$survJumpC, start = 100)/denom,
  "unfavorable" = -calcIntegralProba_cpp(outSurv$survJumpT, start = 87)/denom)
#+END_SRC

#+RESULTS:
:   favorable unfavorable 
:   0.5058685   0.3770426

** Bias correction in presence of missing values / censored 

In presence of censoring or missing values, some pairs may be
classified as uninformative. This is likely to bias the estimate of
the net survival. Two corrections are currently proposed to correct
this bias.

For instance consider the following data:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
set.seed(10)
dt <- simBuyseTest(5e2, latent = TRUE, argsCont = NULL,
                   argsTTE = list(rates.T = 2, rates.C = 1, rates.Censoring = 3))
dt[, status1 := 1]
head(dt)
#+END_SRC

#+RESULTS:
:    Treatment toxicity eventtimeUncensored eventtimeCensoring eventtime status status1
: 1:         C        0           0.1588268          2.6268101 0.1588268      1       1
: 2:         C        1           1.7204676          0.2000192 0.2000192      0       1
: 3:         C        1           0.4900490          0.5747995 0.4900490      1       1
: 4:         C        0           0.1138545          1.5188001 0.1138545      1       1
: 5:         C        1           0.5191035          3.8340048 0.5191035      1       1
: 6:         C        0           0.9405830          1.9078657 0.9405830      1       1

where we have the uncensored event time as well as the censored event
time. The percentage of censored observations is:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt[,mean(status==0)]
#+END_SRC

#+RESULTS:
: [1] 0.317

We would like to be able to recover the true net benefit:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest(Treatment ~ tte(eventtimeUncensored, status1, threshold = 1),
          data = dt,
          method.tte = "Gehan", method.inference = "none", trace = 0)
#+END_SRC

#+RESULTS:
:             endpoint threshold  delta  Delta
:  eventtimeUncensored         1 0.2401 0.2401

using the censored survival times:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest(Treatment ~ tte(eventtime, status, threshold = 1),
          data = dt,
          method.tte = "Gehan", method.inference = "none", trace = 0)
#+END_SRC

#+RESULTS:
:   endpoint threshold  delta  Delta
:  eventtime         1 0.1363 0.1363

As we can see on this example, the net benefit is biased toward 0.

*** Inverse probability-of-censoring weights (IPCW)

With IPCW the weights of the non-informative pairs is redistributed to
the informative pairs. This is only a good strategy when there are no
neutral pairs or there are no lower priority endpoints. This gives an
estimate much closer to the true net benefit:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT <- BuyseTest(Treatment ~ tte(eventtime, status, threshold = 1),
                data = dt, keep.pairScore = TRUE, trace = 0,
                method.tte = "Gehan", method.inference = "none", correction.uninf = 2)
summary(BT)
#+END_SRC


#+RESULTS:
#+begin_example
        Generalized pairwise comparison with 1 prioritized endpoint

 > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
 > null hypothesis : Delta == 0 
 > treatment groups: C (control) vs. T (treatment) 
 > censored pairs  : uninformative pairs
 > uninformative pairs: no contribution, their weight is passed to the informative pairs using IPCW
 > results
  endpoint threshold total favorable unfavorable neutral uninf  delta  Delta
 eventtime         1   100     37.11       12.34   50.54     0 0.2477 0.2477
#+end_example

We can also see that no pair is finally classified as non
informative. To get some inside about the correction we can look at
the scores of the pairs:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iScore <- getPairScore(BT, endpoint = 1)
#+END_SRC

#+RESULTS:

To get a synthetic view, we only look at the unique
favorable/unfavorable/neutral/uniformative results:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iScore[,.SD[1], by = c("favorable","unfavorable","neutral","uninformative")]
#+END_SRC

#+RESULTS:
:    favorable unfavorable neutral uninformative strata index.C index.T weight favorable.corrected unfavorable.corrected neutral.corrected
: 1:         0           0       1             0      1       1     501      1             0.00000               0.00000           1.81657
: 2:         0           0       0             1      1       2     501      1             0.00000               0.00000           0.00000
: 3:         0           1       0             0      1      10     501      1             0.00000               1.81657           0.00000
: 4:         1           0       0             0      1       1     504      1             1.81657               0.00000           0.00000

We can see that the favorable/unfavorable/neutral pairs have seen
their contribution multiplied by:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iScore[,1/mean(favorable + unfavorable + neutral)]
#+END_SRC

#+RESULTS:
: [1] 1.81657

i.e. the inverse probability of being informative. 

*** Correction at the pair level

Another possible correction is to distribute the non-informative
weight of a pair to the average favorable/unfavorable/neutral
probability observed on the sample:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BT <- BuyseTest(Treatment ~ tte(eventtime, status, threshold = 1),
                data = dt, keep.pairScore = TRUE, trace = 0,
                method.tte = "Gehan", method.inference = "none", correction.uninf = TRUE)
summary(BT)
#+END_SRC

#+RESULTS:
#+begin_example
        Generalized pairwise comparison with 1 prioritized endpoint

 > statistic       : net chance of a better outcome (delta: endpoint specific, Delta: global) 
 > null hypothesis : Delta == 0 
 > treatment groups: C (control) vs. T (treatment) 
 > censored pairs  : uninformative pairs
 > uninformative pairs: score equals the averaged score of all informative pairs
 > results
  endpoint threshold total favorable unfavorable neutral uninf  delta  Delta
 eventtime         1   100     37.11       12.34   50.54     0 0.2477 0.2477
#+end_example


Looking at the scores of the pairs:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iScore <- getPairScore(BT, endpoint = 1)
iScore[,.SD[1], by = c("favorable","unfavorable","neutral","uninformative")]
#+END_SRC

#+RESULTS:
:    favorable unfavorable neutral uninformative strata index.C index.T weight favorable.corrected unfavorable.corrected neutral.corrected
: 1:         0           0       1             0      1       1     501      1            0.000000             0.0000000         1.0000000
: 2:         0           0       0             1      1       2     501      1            0.371118             0.1234396         0.5054424
: 3:         0           1       0             0      1      10     501      1            0.000000             1.0000000         0.0000000
: 4:         1           0       0             0      1       1     504      1            1.000000             0.0000000         0.0000000

we can see that the corrected probability have not changed for the
informative pairs, but for the non-informative they have been set to:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
iScore[, .(favorable = weighted.mean(favorable, w = 1-uninformative), 
           unfavorable = weighted.mean(unfavorable, w = 1-uninformative), 
           neutral = weighted.mean(neutral, w = 1-uninformative))]
#+END_SRC

#+RESULTS:
:    favorable unfavorable   neutral
: 1:  0.371118   0.1234396 0.5054424

** Modifying default options
The =BuyseTest.options= method enable to set the default options of
the =BuyseTest= function. Initially the default options are:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest.options()
#+END_SRC

#+RESULTS:
#+begin_example
$check
[1] TRUE

$conf.level
[1] 0.95

$correction.uninf
[1] FALSE

$cpus
[1] 1

$keep.pairScore
[1] FALSE

$keep.survival
[1] TRUE

$method.inference
[1] "stratified permutation"

$method.tte
[1] "Peron"

$n.resampling
[1] 1000

$neutral.as.uninf
[1] TRUE

$seed
[1] 10

$statistic
[1] "netChance"

$trace
[1] 2
#+end_example

The following code enables to change =trace= to 0:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest.options(trace = 0)
#+END_SRC

#+RESULTS:

To restore the original default options do:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
BuyseTest.options(reinitialise = TRUE)
#+END_SRC

#+RESULTS:

* Information about the R session used for this document

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
sessionInfo()
#+END_SRC

#+RESULTS:
#+begin_example
R version 3.4.0 (2017-04-21)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 7 x64 (build 7601) Service Pack 1

Matrix products: default

locale:
[1] LC_COLLATE=Danish_Denmark.1252  LC_CTYPE=Danish_Denmark.1252    LC_MONETARY=Danish_Denmark.1252 LC_NUMERIC=C                   
[5] LC_TIME=Danish_Denmark.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] BuyseTest_1.4.2   data.table_1.11.4 Rcpp_0.12.17      prodlim_1.6.1    

loaded via a namespace (and not attached):
 [1] lattice_0.20-35    grid_3.4.0         R6_2.2.1           stats4_3.4.0       magrittr_1.5       KernSmooth_2.23-15 rlang_0.2.0        testthat_2.0.0    
 [9] Matrix_1.2-9       lava_1.6.1         splines_3.4.0      tools_3.4.0        survival_2.41-3    parallel_3.4.0     compiler_3.4.0
#+end_example


